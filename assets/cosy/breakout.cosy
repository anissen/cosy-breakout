
foreign fn text(str Str, x Num, y Num) Void
foreign fn fill_rect(x Num, y Num, width Num, height Num) Void
foreign fn fill_circle(x Num, y Num, radius Num) Void
foreign fn clear() Void
foreign fn color(c Str) Void
foreign var mouse_x Num

// colors from here: https://lospec.com/palette-list/bluedream4
var color_background = '#ecf2cb'
var color_primary = '#1f285d'
var color_secondary = '#4b849a'
var color_tertiary = '#98d8b1'

var screen_width = 800
var screen_height = 600

var brick_width = 100
var brick_height = 50
var brick_padding = 20

// TODO: Make this a struct
var paddle_width = 100
var paddle_height = 20
var paddle_y = screen_height - paddle_height / 2 - 50

// TODO: Make this a struct
var ball_radius = 10
mut ball_x = screen_width / 2 - ball_radius / 2
mut ball_y = paddle_y - 20 - ball_radius / 2
mut ball_x_speed = 5
mut ball_y_speed = -4

// struct Ball {
//     mut x Num,
//     mut y Num,
//     mut x_speed Num,
//     mut y_speed Num,
//     var radius Num,
// }

struct Brick {
    var x Num
    var y Num
    mut lives Num = 1
}
mut bricks Array Brick = []

mut score = 0

// setup bricks
for x in 0..6 {
    for y in 0..5 {
        mut lives = 1
        if y % 2 == 0 {
            lives = 2
        }
        var brick = Brick {
            x = 50 + x * (brick_width + brick_padding),
            y = 100 + y * (brick_height + brick_padding),
            lives = lives,
        }
        bricks.push(brick)
    }
}

// fn collision(x1 Num, y1 Num, width1 Num, height1 Num, x2 Num, y2 Num, width2 Num, height2 Num) Bool { // TODO: Should probably be `fn collision(rect1 Rect, rect2 Rect)` instead
//     return x1 < x2 + width2 && x1 + width1 > x2 && y1 < y2 + height2 && y1 + height1 > y2
// }
// fn ball_collision(x Num, y Num, width Num, height Num) Bool {
//     return ball_x + ball_radius >= x and ball_x <= x + width and ball_y + ball_radius >= y and ball_y <= y + height
// }

fn ball_collision(x Num, y Num, width Num, height Num) Bool {
    var vertical_hit   = (ball_y >= y and ball_y <= y + height) or                             // ball top inside rect
                         (ball_y + ball_radius >= y and ball_y + ball_radius <= y + height) or // ball bottom inside rect
                         (ball_y <= y and ball_y + ball_radius >= y + height)                  // ball contains rect
    var horizontal_hit = (ball_x >= x and ball_x <= x + width) or                              // ball left inside rect
                         (ball_x + ball_radius >= x and ball_x + ball_radius <= x + width) or  // ball right inside rect
                         (ball_x <= x and ball_x + ball_radius >= x + width)                   // ball contains rect
    return vertical_hit and horizontal_hit
}

fn _update() { // TODO: Should include a delta time
    // background(color_background)
    color(color_background)
    clear()
   
    color(color_primary)
    text('Cosy Breakout! Score: {score}', 100, 20)

    // paddle
    color(color_tertiary)
    mut paddle_x = mouse_x - paddle_width / 2
    if paddle_x < 0 {
        paddle_x = 0
    } else if paddle_x > screen_width - paddle_width {
        paddle_x = screen_width - paddle_width
    }
    fill_rect(paddle_x, paddle_y, paddle_width, paddle_height)

    // ball
    ball_x += ball_x_speed
    ball_y += ball_y_speed
    if ball_x <= 0 or ball_x + ball_radius >= screen_width {
        ball_x_speed = -ball_x_speed
    }
    if ball_y <= 0 or ball_y + ball_radius >= screen_height {
        ball_y_speed = -ball_y_speed
    }
    color(color_primary)
    fill_circle(ball_x, ball_y, ball_radius)

    if ball_collision(paddle_x, paddle_y, paddle_width, paddle_height) {
        ball_y_speed *= -1
        // TODO: Should probably just rotate the speed vectors instead of overwriting them (which may even slow the ball)
        ball_x_speed = (ball_x - (paddle_x + paddle_width / 2)) / (paddle_width / 2) * 5
    }
    
    // bricks
    for brick in bricks {
        if brick.lives <= 0 {
            continue
        }
        // if ball_collision(brick.x, brick.y, brick_width, brick_height) {
        //     brick.lives -= 1
        //     ball_y_speed = -ball_y_speed
        //     ball_x_speed = -ball_x_speed
        //     if brick.lives <= 0 {
        //         score += 1
        //     }
        // } else {
        //     if brick.lives == 2 { // TODO: Should be a switch/match statement
        //         color(color_tertiary)
        //     } else {
        //         color(color_secondary)
        //     }
        //     fill_rect(brick.x, brick.y, brick_width, brick_height)
        // }

        var ball_top = ball_y - ball_radius
        var ball_bottom = ball_y + ball_radius
        var ball_right = ball_x + ball_radius
        var ball_left = ball_x - ball_radius
        var brick_bottom = brick.y + brick_height
        var brick_right = brick.x + brick_width
        var is_inside_brick_width = ball_right >= brick.x and ball_left <= brick.x + brick_width
        var is_inside_brick_height =  ball_bottom >= brick.y and ball_top <= brick.y + brick_height

        // Collision logic: ball vs bricks
        if ball_top <= brick_bottom and ball_top > brick_bottom + ball_y_speed and is_inside_brick_width and ball_y_speed < 0 {
            // Hit from below
            brick.lives -= 1
            ball_y_speed *= -1
        } else if ball_bottom >= brick.y and ball_bottom < brick.y + ball_y_speed and is_inside_brick_width and ball_y_speed > 0 {
            // Hit from above
            brick.lives -= 1
            ball_y_speed *= -1
        } else if ball_right >= brick.x and ball_right < brick.x + ball_x_speed and is_inside_brick_height and ball_x_speed > 0 {
            // Hit from left
            brick.lives -= 1
            ball_x_speed *= -1
        } else if ball_left <= brick_right and ball_left > brick_right + ball_x_speed and is_inside_brick_height and ball_x_speed < 0 {
            // Hit from right
            brick.lives -= 1
            ball_x_speed *= -1
        }
        
        if brick.lives == 2 { // TODO: Should be a switch/match statement
            color(color_tertiary)
        } else {
            color(color_secondary)
        }
        fill_rect(brick.x, brick.y, brick_width, brick_height)
    }

}