
foreign fn text(str Str, x Num, y Num) Void
foreign fn fill_rect(x Num, y Num, width Num, height Num) Void
foreign fn fill_circle(x Num, y Num, radius Num) Void
foreign fn clear() Void
foreign fn color(c Str) Void
foreign var mouse_x Num

// colors from here: https://lospec.com/palette-list/bluedream4
var color_background = '#ecf2cb'
var color_primary = '#1f285d'
var color_secondary = '#4b849a'
var color_tertiary = '#98d8b1'

var screen_width = 800
var screen_height = 600

var brick_width = 100
var brick_height = 50
var brick_padding = 20

// TODO: Make this a struct
var paddle_width = 100
var paddle_height = 20
var paddle_y = screen_height - paddle_height / 2 - 50

// TODO: Make this a struct
var ball_radius = 10
mut ball_x = screen_width / 2 - ball_radius / 2
mut ball_y = paddle_y - 20 - ball_radius / 2
mut ball_x_speed = 5
mut ball_y_speed = -4

// struct Ball {
//     mut x Num,
//     mut y Num,
//     mut x_speed Num,
//     mut y_speed Num,
//     var radius Num,
// }

struct Brick {
    var x Num
    var y Num
    mut lives Num = 1
}
mut bricks Array Brick = []

mut score = 0

// setup bricks
for x in 0..6 {
    for y in 0..5 {
        mut lives = 1
        if y % 2 == 0 {
            lives = 2
        }
        var brick = Brick {
            x = 50 + x * (brick_width + brick_padding),
            y = 100 + y * (brick_height + brick_padding),
            lives = lives,
        }
        bricks.push(brick)
    }
}

fn ball_collision(x Num, y Num, width Num, height Num) Bool {
    var ball_top = ball_y - ball_radius
    var ball_bottom = ball_y + ball_radius
    var ball_right = ball_x + ball_radius
    var ball_left = ball_x - ball_radius
    var bottom = y + height
    var right = x + width
    var is_inside_width = ball_right >= x and ball_left <= x + width
    var is_inside_height =  ball_bottom >= y and ball_top <= y + height

    if ball_top <= bottom and ball_top > bottom + ball_y_speed and is_inside_width and ball_y_speed < 0 {
        // Hit from below
        ball_y_speed *= -1
        return true
    } else if ball_bottom >= y and ball_bottom < y + ball_y_speed and is_inside_width and ball_y_speed > 0 {
        // Hit from above
        ball_y_speed *= -1
        return true
    } else if ball_right >= x and ball_right < x + ball_x_speed and is_inside_height and ball_x_speed > 0 {
        // Hit from left
        ball_x_speed *= -1
        return true
    } else if ball_left <= right and ball_left > right + ball_x_speed and is_inside_height and ball_x_speed < 0 {
        // Hit from right
        ball_x_speed *= -1
        return true
    }
    return false
}

fn _update() { // TODO: Should include a delta time
    // background(color_background)
    color(color_background)
    clear()
   
    color(color_primary)
    text('Cosy Breakout! Score: {score}', 50, 20) // TODO: Should be centered

    // paddle
    color(color_tertiary)
    mut paddle_x = mouse_x - paddle_width / 2
    if paddle_x < 0 {
        paddle_x = 0
    } else if paddle_x > screen_width - paddle_width {
        paddle_x = screen_width - paddle_width
    }
    fill_rect(paddle_x, paddle_y, paddle_width, paddle_height)

    // ball
    ball_x += ball_x_speed
    ball_y += ball_y_speed
    if ball_x <= 0 or ball_x + ball_radius >= screen_width {
        ball_x_speed = -ball_x_speed
    }
    if ball_y <= 0 or ball_y + ball_radius >= screen_height {
        ball_y_speed = -ball_y_speed
    }
    color(color_primary)
    fill_circle(ball_x, ball_y, ball_radius)

    if ball_collision(paddle_x, paddle_y, paddle_width, paddle_height) {
        // TODO: Should probably just rotate the speed vectors instead of overwriting them (which may even slow the ball)
        ball_x_speed = (ball_x - (paddle_x + paddle_width / 2)) / (paddle_width / 2) * 5
    }
    
    // bricks
    for brick in bricks {
        if brick.lives <= 0 {
            continue
        }

        if ball_collision(brick.x, brick.y, brick_width, brick_height) {
            brick.lives -= 1
            if brick.lives <= 0 {
                score += 1
            }
        } else {
            if brick.lives == 2 { // TODO: Should be a switch/match statement
                color(color_tertiary)
            } else {
                color(color_secondary)
            }
            fill_rect(brick.x, brick.y, brick_width, brick_height)
        }
    }

}