foreign fn text(str Str, x Num, y Num) Void
foreign fn fill_rect(x Num, y Num, width Num, height Num) Void
foreign fn fill_circle(x Num, y Num, radius Num) Void
foreign fn clear() Void
foreign fn color(c Str) Void
foreign var mouse_x Num

// colors from here: https://lospec.com/palette-list/bluedream4
var color_background = '#ecf2cb'
var color_primary = '#1f285d'
var color_secondary = '#4b849a'
var color_tertiary = '#98d8b1'

var screen_width = 800
var screen_height = 600

var brick_width = 100
var brick_height = 50
var brick_padding = 20

var paddle_width = 100
var paddle_height = 20

struct Paddle {
    mut x Num
    mut y Num
    var width Num
    var height Num
}
mut paddle = Paddle {
    x = screen_width / 2 - paddle_width / 2,
    y = screen_height - paddle_height / 2 - 50,
    width = 100,
    height = 20,
}

struct Ball {
    mut x Num
    mut y Num
    mut speed_x Num
    mut speed_y Num
    var radius Num
}
mut ball = Ball { 
    x = paddle.x + paddle.width / 2,
    y = paddle.y - 20,
    speed_x = 5,
    speed_y = -5,
    radius = 10,
 }

struct Brick {
    var x Num
    var y Num
    mut lives Num = 1
}
mut bricks Array Brick = []

mut score = 0

// setup bricks
for x in 0..6 {
    for y in 0..5 {
        mut lives = 1
        if y % 2 == 0 {
            lives = 2
        }
        var brick = Brick {
            x = 50 + x * (brick_width + brick_padding),
            y = 100 + y * (brick_height + brick_padding),
            lives = lives,
        }
        bricks.push(brick)
    }
}

fn ball_collision(x Num, y Num, width Num, height Num) Bool {
    var ball_top = ball.y - ball.radius
    var ball_bottom = ball.y + ball.radius
    var ball_right = ball.x + ball.radius
    var ball_left = ball.x - ball.radius
    var bottom = y + height
    var right = x + width
    var is_inside_width = ball_right >= x and ball_left <= x + width
    var is_inside_height =  ball_bottom >= y and ball_top <= y + height

    if ball_top <= bottom and ball_top > bottom + ball.speed_y and is_inside_width and ball.speed_y < 0 {
        // Hit from below
        ball.speed_y *= -1
        return true
    } else if ball_bottom >= y and ball_bottom < y + ball.speed_y and is_inside_width and ball.speed_y > 0 {
        // Hit from above
        ball.speed_y *= -1
        return true
    } else if ball_right >= x and ball_right < x + ball.speed_x and is_inside_height and ball.speed_x > 0 {
        // Hit from left
        ball.speed_x *= -1
        return true
    } else if ball_left <= right and ball_left > right + ball.speed_x and is_inside_height and ball.speed_x < 0 {
        // Hit from right
        ball.speed_x *= -1
        return true
    }
    return false
}

fn _update() { // TODO: Should include a delta time
    // background(color_background)
    color(color_background)
    clear()
   
    color(color_primary)
    text('Cosy Breakout! Score: {score}', 50, 20) // TODO: Should be centered

    // paddle
    color(color_tertiary)
    paddle.x = mouse_x - paddle.width / 2
    if paddle.x < 0 {
        paddle.x = 0
    } else if paddle.x > screen_width - paddle.width {
        paddle.x = screen_width - paddle.width
    }
    fill_rect(paddle.x, paddle.y, paddle.width, paddle.height)

    // ball
    ball.x += ball.speed_x
    ball.y += ball.speed_y
    if ball.x <= 0 or ball.x + ball.radius >= screen_width {
        ball.speed_x = -ball.speed_x
    }
    if ball.y <= 0 or ball.y + ball.radius >= screen_height {
        ball.speed_y = -ball.speed_y
    }
    color(color_primary)
    fill_circle(ball.x, ball.y, ball.radius)

    if ball_collision(paddle.x, paddle.y, paddle.width, paddle.height) {
        // TODO: Should probably just rotate the speed vectors instead of overwriting them (which may even slow the ball)
        ball.speed_x = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2) * 5
    }
    
    // bricks
    for brick in bricks {
        if brick.lives <= 0 {
            continue
        }

        if ball_collision(brick.x, brick.y, brick_width, brick_height) {
            brick.lives -= 1
            if brick.lives <= 0 {
                score += 1
            }
        } else {
            if brick.lives == 2 { // TODO: Should be a switch/match statement
                color(color_tertiary)
            } else {
                color(color_secondary)
            }
            fill_rect(brick.x, brick.y, brick_width, brick_height)
        }
    }
}